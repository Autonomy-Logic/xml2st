import traceback, os
from jinja2 import Environment, FileSystemLoader
from runtime.typemapping import DebugTypesSize
import util.paths as paths
import hashlib


class ProjectController:

    def __init__(self):
        self.__loader = FileSystemLoader(
            os.path.join(paths.AbsDir(__file__), "templates")
        )
        self.ResetIECProgramsAndVariables()

    def SetCSVFile(self, filename):
        """
        Open a CSV file containing IEC variables.
        """
        self._csvfile = filename

    def ResetIECProgramsAndVariables(self):
        """
        Reset variable and program list that are parsed from
        CSV file generated by IEC2C compiler.
        """
        self._ProgramList = None
        self._VariablesList = None
        self._DbgVariablesList = None
        self._IECPathToIdx = {}
        self._Ticktime = 0
        self.TracedIECPath = []
        self.TracedIECTypes = []

    def GetIECProgramsAndVariables(self):
        """
        Parse CSV-like file  VARIABLES.csv resulting from IEC2C compiler.
        Each section is marked with a line staring with '//'
        list of all variables used in various POUs
        """
        if self._ProgramList is None or self._VariablesList is None:
            try:
                # describes CSV columns
                ProgramsListAttributeName = ["num", "C_path", "type"]
                VariablesListAttributeName = [
                    "num",
                    "vartype",
                    "IEC_path",
                    "C_path",
                    "type",
                    "derived",
                    "retain",
                ]
                self._ProgramList = []
                self._VariablesList = []
                self._DbgVariablesList = []
                self._IECPathToIdx = {}

                # Separate sections
                ListGroup = []
                for line in open(self._csvfile, "r").readlines():
                    strippedline = line.strip()
                    if strippedline.startswith("//"):
                        # Start new section
                        ListGroup.append([])
                    elif len(strippedline) > 0 and len(ListGroup) > 0:
                        # append to this section
                        ListGroup[-1].append(strippedline)

                # first section contains programs
                for line in ListGroup[0]:
                    # Split and Maps each field to dictionnary entries
                    attrs = dict(
                        list(zip(ProgramsListAttributeName, line.strip().split(";")))
                    )
                    # Truncate "C_path" to remove conf an resources names
                    attrs["C_path"] = "__".join(attrs["C_path"].split(".", 2)[1:])
                    # Push this dictionnary into result.
                    self._ProgramList.append(attrs)

                # second section contains all variables
                config_FBs = {}
                Idx = 0
                for line in ListGroup[1]:
                    # Split and Maps each field to dictionnary entries
                    attrs = dict(
                        list(zip(VariablesListAttributeName, line.strip().split(";")))
                    )
                    # Truncate "C_path" to remove conf an resources names
                    parts = attrs["C_path"].split(".", 2)
                    if len(parts) > 2:
                        config_FB = config_FBs.get(tuple(parts[:2]))
                        if config_FB:
                            parts = [config_FB] + parts[2:]
                            attrs["C_path"] = ".".join(parts)
                        else:
                            attrs["C_path"] = "__".join(parts[1:])
                    else:
                        attrs["C_path"] = "__".join(parts)
                        if attrs["vartype"] == "FB":
                            config_FBs[tuple(parts)] = attrs["C_path"]
                    if attrs["vartype"] != "FB" and attrs["type"] in DebugTypesSize:
                        # Push this dictionnary into result.
                        self._DbgVariablesList.append(attrs)
                        # Fill in IEC<->C translation dicts
                        IEC_path = attrs["IEC_path"]
                        self._IECPathToIdx[IEC_path] = (Idx, attrs["type"])
                        # Ignores numbers given in CSV file
                        # Idx=int(attrs["num"])
                        # Count variables only, ignore FBs
                        Idx += 1
                    self._VariablesList.append(attrs)

                # third section contains ticktime
                if len(ListGroup) > 2:
                    self._Ticktime = int(ListGroup[2][0])

            except Exception:
                self.ResetIECProgramsAndVariables()
                raise Exception(
                    f"Cannot open/parse VARIABLES.csv!\n{traceback.format_exc()}"
                )

    def Generate_plc_debug_cvars(self):
        """
        Generate debug C variables out of PLC variable list
        """
        if not self._DbgVariablesList and not self._VariablesList:
            self.GetIECProgramsAndVariables()
        type_suffix = {
            "EXT": "_P_ENUM",
            "IN": "_P_ENUM",
            "MEM": "_O_ENUM",
            "OUT": "_O_ENUM",
            "VAR": "_ENUM",
        }

        variable_decl_array = [
            f"{{&({v['C_path']}), {v['type']}{type_suffix[v['vartype']]}}}"
            for v in self._DbgVariablesList
        ]

        enum_types = list(
            set([v["type"] + type_suffix[v["vartype"]] for v in self._DbgVariablesList])
        )
        types = {
            "EXT": ("extern __IEC_", "_p"),
            "IN": ("extern __IEC_", "_p"),
            "MEM": ("extern __IEC_", "_p"),
            "OUT": ("extern __IEC_", "_p"),
            "VAR": ("extern __IEC_", "_t"),
            "FB": ("extern ", ""),
        }

        extern_variables_declarations = [
            f"{types[v['vartype']][0]}{v['type']}{types[v['vartype']][1]} {v['C_path']};"
            for v in self._VariablesList
            if "." not in v["C_path"]
        ]
        return variable_decl_array, extern_variables_declarations, enum_types

    def Generate_embedded_plc_debugger(self, st_file):
        dvars, externs, enums = self.Generate_plc_debug_cvars()

        template = Environment(loader=self.__loader).get_template("debug.c.j2")
        cfile = os.path.join(paths.AbsDir(self._csvfile), "debug.c")
        debug_text = template.render(
            debug={
                "externs": externs,
                "vars": dvars,
                "enums": enums,
                "types": list(set(a.split("_", 1)[0] for a in enums)),
            }
        )

        with open(cfile, "w") as f:
            f.write(debug_text)

        # Wrap debugger code around (* comments *)
        MD5 = hashlib.md5(open(st_file, "rb").read()).hexdigest()
        if MD5 is None:
            raise ("Error building project: md5 object is null\n")

        # Add MD5 value to debug.cpp file
        c_debug = 'char md5[] = "' + MD5 + '";\n' + debug_text

        return cfile, c_debug
